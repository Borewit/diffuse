module UI.Queue exposing (initialModel, update)

import List.Extra as List
import Queue exposing (..)
import Replying exposing (R3D3)
import Return3 as R3
import Time
import Tracks exposing (IdentifiedTrack)
import UI.Ports as Ports
import UI.Queue.Common exposing (makeItem)
import UI.Queue.Core exposing (..)
import UI.Queue.Fill as Fill
import UI.Reply exposing (Reply(..))



-- ðŸŒ³


initialModel : Model
initialModel =
    { activeItem = Nothing
    , future = []
    , ignored = []
    , past = []

    --
    , repeat = False
    , shuffle = False
    }



-- ðŸ“£


update : Msg -> Model -> R3D3 Model Msg Reply
update msg model =
    case msg of
        ------------------------------------
        -- Combos
        ------------------------------------
        InjectFirstAndPlay identifiedTrack ->
            let
                ( a, b, _ ) =
                    update (InjectFirst [ identifiedTrack ]) model

                ( x, y, z ) =
                    update Shift a
            in
            ( x, Cmd.batch [ b, y ], z )

        ------------------------------------
        -- Future
        ------------------------------------
        -- # InjectFirst
        -- > Add an item in front of the queue.
        --
        InjectFirst identifiedTracks ->
            let
                ( items, tracks ) =
                    ( List.map (makeItem True) identifiedTracks
                    , List.map Tuple.second identifiedTracks
                    )

                cleanedFuture =
                    List.foldl
                        (\track future ->
                            Fill.cleanAutoGenerated model.shuffle track.id future
                        )
                        model.future
                        tracks
            in
            ( { model | future = items ++ cleanedFuture }
            , Cmd.none
            , Just [ FillQueue ]
            )

        -- # InjectLast
        -- > Add an item after the last manual entry
        --   (ie. after the last injected item).
        --
        InjectLast identifiedTracks ->
            let
                ( items, tracks ) =
                    ( List.map (makeItem True) identifiedTracks
                    , List.map Tuple.second identifiedTracks
                    )

                cleanedFuture =
                    List.foldl
                        (\track future ->
                            Fill.cleanAutoGenerated model.shuffle track.id future
                        )
                        model.future
                        tracks

                manualItems =
                    cleanedFuture
                        |> List.filter (.manualEntry >> (==) True)
                        |> List.length
            in
            ( { model
                | future =
                    []
                        ++ List.take manualItems cleanedFuture
                        ++ items
                        ++ List.drop manualItems cleanedFuture
              }
            , Cmd.none
            , Just [ FillQueue ]
            )

        -----------------------------------------
        -- Position
        -----------------------------------------
        -- # Rewind
        -- > Put the next item in the queue as the current one.
        --
        Rewind ->
            changeActiveItem
                (List.last model.past)
                { model
                    | future =
                        model.activeItem
                            |> Maybe.map (\item -> item :: model.future)
                            |> Maybe.withDefault model.future
                    , past =
                        model.past
                            |> List.init
                            |> Maybe.withDefault []
                }

        -- # Shift
        -- > Put the next item in the queue as the current one.
        --
        Shift ->
            changeActiveItem
                (List.head model.future)
                { model
                    | future =
                        model.future
                            |> List.drop 1
                    , past =
                        model.activeItem
                            |> Maybe.map List.singleton
                            |> Maybe.map (List.append model.past)
                            |> Maybe.withDefault model.past
                }

        ------------------------------------
        -- Contents
        ------------------------------------
        -- # Fill
        -- > Fill the queue with items.
        --
        Fill timestamp tracks ->
            ( fillQueue timestamp tracks model, Cmd.none, Nothing )

        -- # Reset
        -- > Renew the queue, meaning that the auto-generated items in the queue
        --   are removed and new items are added.
        --
        Reset ->
            let
                newFuture =
                    List.filter (.manualEntry >> (==) True) model.future
            in
            ( { model | future = newFuture, ignored = [] }
            , Cmd.none
            , Just [ FillQueue ]
            )

        ------------------------------------
        -- Settings
        ------------------------------------
        ToggleRepeat ->
            ( { model | repeat = not model.repeat }
            , Ports.setRepeat (not model.repeat)
            , Just [ SaveEnclosedUserData ]
            )

        ToggleShuffle ->
            { model | shuffle = not model.shuffle }
                |> update Reset
                |> Replying.addReply SaveEnclosedUserData



-- ðŸ“£  â–‘â–‘  COMMON


changeActiveItem : Maybe Item -> Model -> R3D3 Model Msg Reply
changeActiveItem maybeItem model =
    ( { model | activeItem = maybeItem }
    , Cmd.none
    , Just [ ActiveQueueItemChanged maybeItem, FillQueue ]
    )


fillQueue : Time.Posix -> List IdentifiedTrack -> Model -> Model
fillQueue timestamp availableTracks model =
    let
        nonMissingTracks =
            List.filter
                (Tuple.second >> .id >> (/=) Tracks.missingId)
                availableTracks
    in
    model
        |> (\m ->
                -- Empty the ignored list when we are ignoring all the tracks
                if List.length model.ignored == List.length nonMissingTracks then
                    { m | ignored = [] }

                else
                    m
           )
        |> (\m ->
                -- Fill using the appropiate method
                case m.shuffle of
                    False ->
                        { m | future = Fill.ordered timestamp nonMissingTracks m }

                    True ->
                        { m | future = Fill.shuffled timestamp nonMissingTracks m }
           )
