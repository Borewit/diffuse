module UI.Queue exposing (initialModel, update)

import Conditional exposing (..)
import List.Extra as List
import Queue exposing (..)
import Return3 as Return exposing (..)
import Time
import Tracks exposing (IdentifiedTrack)
import UI.Ports as Ports
import UI.Queue.Common exposing (makeItem)
import UI.Queue.Core exposing (..)
import UI.Queue.Fill as Fill
import UI.Reply exposing (Reply(..))



-- ðŸŒ³


initialModel : Model
initialModel =
    { activeItem = Nothing
    , future = []
    , ignored = []
    , past = []

    --
    , repeat = False
    , shuffle = False
    }



-- ðŸ“£


update : Msg -> Model -> Return Model Msg Reply
update msg model =
    case msg of
        ------------------------------------
        -- Combos
        ------------------------------------
        InjectFirstAndPlay identifiedTrack ->
            [ identifiedTrack ]
                |> InjectFirst { showNotification = False }
                |> updateWithModel model
                |> andThen (update Shift)

        ------------------------------------
        -- Future
        ------------------------------------
        -- # InjectFirst
        -- > Add an item in front of the queue.
        --
        InjectFirst { showNotification } identifiedTracks ->
            let
                ( items, tracks ) =
                    ( List.map (makeItem True) identifiedTracks
                    , List.map Tuple.second identifiedTracks
                    )

                cleanedFuture =
                    List.foldl
                        (\track future ->
                            Fill.cleanAutoGenerated model.shuffle track.id future
                        )
                        model.future
                        tracks
            in
            [ case tracks of
                [ t ] ->
                    ("__" ++ t.tags.title ++ "__ will be played next")
                        |> ShowSuccessNotification

                list ->
                    list
                        |> List.length
                        |> String.fromInt
                        |> (\s -> "__" ++ s ++ " tracks__ will be played next")
                        |> ShowSuccessNotification
            ]
                |> (\list -> ifThenElse showNotification list [])
                |> returnRepliesWithModel { model | future = items ++ cleanedFuture }
                |> addReply FillQueue

        -- # InjectLast
        -- > Add an item after the last manual entry
        --   (ie. after the last injected item).
        --
        InjectLast { showNotification } identifiedTracks ->
            let
                ( items, tracks ) =
                    ( List.map (makeItem True) identifiedTracks
                    , List.map Tuple.second identifiedTracks
                    )

                cleanedFuture =
                    List.foldl
                        (\track future ->
                            Fill.cleanAutoGenerated model.shuffle track.id future
                        )
                        model.future
                        tracks

                manualItems =
                    cleanedFuture
                        |> List.filter (.manualEntry >> (==) True)
                        |> List.length

                newFuture =
                    []
                        ++ List.take manualItems cleanedFuture
                        ++ items
                        ++ List.drop manualItems cleanedFuture
            in
            [ case tracks of
                [ t ] ->
                    ("__" ++ t.tags.title ++ "__ was added to the queue")
                        |> ShowSuccessNotification

                list ->
                    list
                        |> List.length
                        |> String.fromInt
                        |> (\s -> "__" ++ s ++ " tracks__ were added to the queue")
                        |> ShowSuccessNotification
            ]
                |> (\list -> ifThenElse showNotification list [])
                |> returnRepliesWithModel { model | future = newFuture }
                |> addReply FillQueue

        -----------------------------------------
        -- Position
        -----------------------------------------
        -- # Rewind
        -- > Put the next item in the queue as the current one.
        --
        Rewind ->
            changeActiveItem
                (List.last model.past)
                { model
                    | future =
                        model.activeItem
                            |> Maybe.map (\item -> item :: model.future)
                            |> Maybe.withDefault model.future
                    , past =
                        model.past
                            |> List.init
                            |> Maybe.withDefault []
                }

        -- # Shift
        -- > Put the next item in the queue as the current one.
        --
        Shift ->
            changeActiveItem
                (List.head model.future)
                { model
                    | future =
                        model.future
                            |> List.drop 1
                    , past =
                        model.activeItem
                            |> Maybe.map List.singleton
                            |> Maybe.map (List.append model.past)
                            |> Maybe.withDefault model.past
                }

        ------------------------------------
        -- Contents
        ------------------------------------
        -- # Fill
        -- > Fill the queue with items.
        --
        Fill timestamp tracks ->
            return (fillQueue timestamp tracks model)

        -- # Reset
        -- > Renew the queue, meaning that the auto-generated items in the queue
        --   are removed and new items are added.
        --
        Reset ->
            let
                newFuture =
                    List.filter (.manualEntry >> (==) True) model.future
            in
            returnRepliesWithModel
                { model | future = newFuture, ignored = [] }
                [ FillQueue ]

        ------------------------------------
        -- Settings
        ------------------------------------
        ToggleRepeat ->
            ( { model | repeat = not model.repeat }
            , Ports.setRepeat (not model.repeat)
            , [ SaveEnclosedUserData ]
            )

        ToggleShuffle ->
            { model | shuffle = not model.shuffle }
                |> update Reset
                |> addReply SaveEnclosedUserData


updateWithModel : Model -> Msg -> Return Model Msg Reply
updateWithModel model msg =
    update msg model



-- ðŸ“£  â–‘â–‘  COMMON


changeActiveItem : Maybe Item -> Model -> Return Model Msg Reply
changeActiveItem maybeItem model =
    returnRepliesWithModel
        { model | activeItem = maybeItem }
        [ ActiveQueueItemChanged maybeItem
        , FillQueue
        ]


fillQueue : Time.Posix -> List IdentifiedTrack -> Model -> Model
fillQueue timestamp availableTracks model =
    let
        nonMissingTracks =
            List.filter
                (Tuple.second >> .id >> (/=) Tracks.missingId)
                availableTracks
    in
    model
        |> (\m ->
                -- Empty the ignored list when we are ignoring all the tracks
                if List.length model.ignored == List.length nonMissingTracks then
                    { m | ignored = [] }

                else
                    m
           )
        |> (\m ->
                -- Fill using the appropiate method
                case m.shuffle of
                    False ->
                        { m | future = Fill.ordered timestamp nonMissingTracks m }

                    True ->
                        { m | future = Fill.shuffled timestamp nonMissingTracks m }
           )
