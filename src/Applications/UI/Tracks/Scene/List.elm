module UI.Tracks.Scene.List exposing (containerId, scrollToNowPlaying, scrollToTop, view)

import Browser.Dom as Dom
import Chunky exposing (..)
import Classes as C
import Color
import Color.Ext as Color
import Conditional exposing (ifThenElse)
import Css
import Html as UnstyledHtml
import Html.Attributes as UnstyledHtmlAttributes
import Html.Events.Extra.Mouse exposing (onWithOptions)
import Html.Styled as Html exposing (Html, text)
import Html.Styled.Attributes exposing (css, fromUnstyled, id, style, tabindex)
import Html.Styled.Events exposing (onClick)
import Html.Styled.Lazy as Lazy
import InfiniteList
import Json.Decode
import Material.Icons exposing (Coloring(..))
import Material.Icons.Av as Icons
import Material.Icons.Navigation as Icons
import Maybe.Extra as Maybe
import Playlists exposing (Playlist)
import Tachyons.Classes as T
import Task
import Tracks exposing (..)
import UI.DnD as DnD
import UI.Kit
import UI.Reply
import UI.Tracks.Core exposing (..)



-- ðŸ—º


type alias Necessities =
    { height : Float, isVisible : Bool }


view : Necessities -> Model -> Html Msg
view necessities model =
    Lazy.lazy7
        lazyView
        necessities
        model.collection.harvested
        model.infiniteList
        model.favouritesOnly
        model.sortBy
        model.sortDirection
        (model.selectedPlaylist
            |> Maybe.map .autoGenerated
            |> Maybe.andThen (\bool -> ifThenElse (not bool) (Just model.listDnD) Nothing)
        )


lazyView : Necessities -> List IdentifiedTrack -> InfiniteList.Model -> Bool -> SortBy -> SortDirection -> Maybe (DnD.Model Int) -> Html Msg
lazyView necessities harvest infiniteList favouritesOnly sortBy sortDirection maybeDnD =
    brick
        [ fromUnstyled (InfiniteList.onScroll InfiniteListMsg)
        , id containerId
        , tabindex (ifThenElse necessities.isVisible 0 -1)
        ]
        [ C.disable_selection
        , T.flex_grow_1
        , T.outline_0
        , T.overflow_x_hidden
        , T.overflow_y_scroll
        , T.vh_25
        ]
        [ -- Header
          ---------
          Lazy.lazy3
            header
            (Maybe.isJust maybeDnD)
            sortBy
            sortDirection

        -- List
        -------
        , Html.fromUnstyled
            (InfiniteList.view
                (InfiniteList.withCustomContainer
                    infiniteListContainer
                    (InfiniteList.config
                        { itemView =
                            case maybeDnD of
                                Just dnd ->
                                    playlistItemView favouritesOnly dnd

                                _ ->
                                    defaultItemView favouritesOnly

                        --
                        , itemHeight = InfiniteList.withVariableHeight dynamicRowHeight
                        , containerHeight = round necessities.height
                        }
                    )
                )
                infiniteList
                harvest
            )
        ]


containerId : String
containerId =
    "diffuse__track-list"


scrollToNowPlaying : List IdentifiedTrack -> IdentifiedTrack -> Cmd Msg
scrollToNowPlaying harvest ( identifiers, _ ) =
    harvest
        |> List.take identifiers.indexInList
        |> List.foldl (\a -> (+) <| dynamicRowHeight 0 a) 0
        |> (\n -> 22 - toFloat rowHeight / 2 + 5 + toFloat n)
        |> Dom.setViewportOf containerId 0
        |> Task.attempt (always Bypass)


scrollToTop : Cmd Msg
scrollToTop =
    Task.attempt (always Bypass) (Dom.setViewportOf containerId 0 0)



-- HEADERS


header : Bool -> SortBy -> SortDirection -> Html Msg
header isPlaylist sortBy sortDirection =
    let
        sortIcon =
            (if sortDirection == Desc then
                Icons.expand_less

             else
                Icons.expand_more
            )
                15
                Inherit

        sortIconHtml =
            Html.fromUnstyled sortIcon

        maybeSortIcon s =
            ifThenElse (sortBy == s) (Just sortIconHtml) Nothing
    in
    brick
        [ css headerStyles ]
        [ T.bg_white, T.flex, T.fw6, T.relative, T.z_5 ]
        (if isPlaylist then
            [ headerColumn "" 4.5 First Nothing Bypass
            , headerColumn "#" 4.5 Between Nothing Bypass
            , headerColumn "Title" 36.0 Between Nothing Bypass
            , headerColumn "Artist" 27.5 Between Nothing Bypass
            , headerColumn "Album" 27.5 Last Nothing Bypass
            ]

         else
            [ headerColumn "" 4.5 First Nothing Bypass
            , headerColumn "Title" 37.5 Between (maybeSortIcon Title) (SortBy Title)
            , headerColumn "Artist" 29.0 Between (maybeSortIcon Artist) (SortBy Artist)
            , headerColumn "Album" 29.0 Last (maybeSortIcon Album) (SortBy Album)
            ]
        )


headerStyles : List Css.Style
headerStyles =
    [ Css.borderBottom3 (Css.px 1) Css.solid (Color.toElmCssColor UI.Kit.colors.subtleBorder)
    , Css.color (Color.toElmCssColor headerTextColor)
    , Css.fontSize (Css.px 11)
    ]


headerTextColor : Color.Color
headerTextColor =
    Color.rgb255 207 207 207



-- HEADER COLUMN


type Pos
    = First
    | Between
    | Last


headerColumn :
    String
    -> Float
    -> Pos
    -> Maybe (Html msg)
    -> msg
    -> Html msg
headerColumn text_ width pos maybeSortIcon msg =
    brick
        [ onClick msg
        , css
            [ Css.borderLeft3
                (Css.px <| ifThenElse (pos /= First) 1 0)
                Css.solid
                (Color.toElmCssColor UI.Kit.colors.subtleBorder)
            , Css.minWidth (Css.px columnMinWidth)
            , Css.width (Css.pct width)
            ]
        ]
        [ T.lh_title
        , T.pv1
        , T.relative

        --
        , ifThenElse (pos == First) T.pl3 T.pl2
        , ifThenElse (pos == Last) T.pr3 T.pr2
        , ifThenElse (pos == First) "" T.pointer
        ]
        [ brick
            [ css [ Css.top (Css.px 1) ] ]
            [ T.relative ]
            [ text text_ ]
        , case maybeSortIcon of
            Just sortIcon ->
                brick
                    [ css sortIconStyles ]
                    [ T.absolute, T.mr1, T.right_0 ]
                    [ sortIcon ]

            Nothing ->
                nothing
        ]


sortIconStyles : List Css.Style
sortIconStyles =
    [ Css.fontSize (Css.px 0)
    , Css.lineHeight (Css.px 0)
    , Css.top (Css.pct 50)
    , Css.transform (Css.translateY <| Css.pct -50)
    ]



-- INFINITE LIST


infiniteListContainer :
    List ( String, String )
    -> List (UnstyledHtml.Html msg)
    -> UnstyledHtml.Html msg
infiniteListContainer styles children =
    UnstyledHtml.div
        (List.map (\( k, v ) -> UnstyledHtmlAttributes.style k v) styles)
        [ (Html.toUnstyled << rawy) <|
            brick
                [ css listStyles ]
                [ T.f6
                , T.pb1
                , T.pt1
                ]
                (List.map Html.fromUnstyled children)
        ]


listStyles : List Css.Style
listStyles =
    [ Css.fontSize (Css.px 12.5) ]


dynamicRowHeight : Int -> IdentifiedTrack -> Int
dynamicRowHeight _ ( i, t ) =
    let
        shouldRenderGroup =
            i.group
                |> Maybe.map (.firstInGroup >> (==) True)
                |> Maybe.withDefault False
    in
    if shouldRenderGroup then
        32 + 18 + 16 + rowHeight

    else
        rowHeight



-- INFINITE LIST ITEM


defaultItemView : Bool -> Int -> Int -> IdentifiedTrack -> UnstyledHtml.Html Msg
defaultItemView favouritesOnly _ idx identifiedTrack =
    let
        ( identifiers, track ) =
            identifiedTrack

        shouldRenderGroup =
            identifiers.group
                |> Maybe.map (.firstInGroup >> (==) True)
                |> Maybe.withDefault False
    in
    Html.toUnstyled <|
        Html.div
            []
            [ if shouldRenderGroup then
                groupNode idx identifiers

              else
                nothing

            --
            , brick
                [ css (rowStyles idx identifiers)
                , contextMenuEvent identifiedTrack
                , mousePlayEvent identifiedTrack
                ]
                [ T.flex
                , T.items_center

                --
                , ifThenElse identifiers.isMissing "" T.pointer
                , ifThenElse identifiers.isSelected T.fw6 ""
                ]
                [ favouriteColumn favouritesOnly identifiers
                , otherColumn 37.5 False track.tags.title
                , otherColumn 29.0 False track.tags.artist
                , otherColumn 29.0 True track.tags.album
                ]
            ]


playlistItemView : Bool -> DnD.Model Int -> Int -> Int -> IdentifiedTrack -> UnstyledHtml.Html Msg
playlistItemView favouritesOnly dnd _ idx identifiedTrack =
    let
        ( identifiers, track ) =
            identifiedTrack

        listIdx =
            identifiers.indexInList

        dragEnv =
            { model = dnd
            , toMsg = ListDragAndDropMsg
            }
    in
    Html.toUnstyled <|
        brick
            ((++)
                [ css (rowStyles idx identifiers)
                , contextMenuEvent identifiedTrack
                , mousePlayEvent identifiedTrack
                , DnD.listenToStart dragEnv listIdx
                ]
                (List.concat
                    [ DnD.listenToEnterLeave dragEnv listIdx
                    , DnD.listenToDrop dragEnv listIdx

                    --
                    , if DnD.isBeingDraggedOver listIdx dnd then
                        [ style
                            "box-shadow"
                            ("0 1px 0 0 " ++ Color.toCssString UI.Kit.colorKit.accent ++ " inset")
                        ]

                      else
                        []
                    ]
                )
            )
            [ T.flex
            , T.items_center

            --
            , ifThenElse identifiers.isMissing "" T.pointer
            , ifThenElse identifiers.isSelected T.fw6 ""
            ]
            [ favouriteColumn favouritesOnly identifiers
            , playlistIndexColumn (Maybe.withDefault 0 identifiers.indexInPlaylist)
            , otherColumn 36.0 False track.tags.title
            , otherColumn 27.5 False track.tags.artist
            , otherColumn 27.5 True track.tags.album
            ]


contextMenuEvent : IdentifiedTrack -> Html.Attribute Msg
contextMenuEvent identifiedTrack =
    identifiedTrack
        |> ShowTrackMenu
        |> onWithOptions
            "contextmenu"
            { stopPropagation = True
            , preventDefault = True
            }
        |> Html.Styled.Attributes.fromUnstyled


mousePlayEvent : IdentifiedTrack -> Html.Attribute Msg
mousePlayEvent ( i, t ) =
    Html.Styled.Events.custom
        "dblclick"
        (Json.Decode.succeed
            { message =
                if i.isMissing then
                    Bypass

                else
                    Reply [ UI.Reply.PlayTrack ( i, t ) ]
            , stopPropagation = True
            , preventDefault = True
            }
        )



-- ROWS


groupNode : Int -> Identifiers -> Html Msg
groupNode idx identifiers =
    let
        groupName =
            identifiers.group
                |> Maybe.map .name
                |> Maybe.withDefault "Unknown"
    in
    brick
        [ css groupStyles ]
        [ T.f7
        , T.fw7
        , T.lh_copy
        , T.pb3
        , T.ph3
        , ifThenElse (0 == idx) T.pt3 T.pt4
        , T.truncate
        ]
        [ inline
            [ T.dib, T.pr2, T.v_mid, C.lh_0 ]
            [ Html.fromUnstyled (Icons.library_music 16 Inherit) ]
        , inline
            [ T.v_mid ]
            [ text groupName ]
        ]


groupStyles : List Css.Style
groupStyles =
    [ Css.color (Color.toElmCssColor UI.Kit.colorKit.base04)
    , Css.fontFamilies UI.Kit.headerFontFamilies
    , Css.fontSize (Css.px 11)
    , Css.letterSpacing (Css.em 0.005)
    ]


rowHeight : Int
rowHeight =
    35


rowStyles : Int -> Identifiers -> List Css.Style
rowStyles idx { isMissing, isNowPlaying } =
    let
        bgColor =
            if isNowPlaying then
                Color.toElmCssColor UI.Kit.colors.selection

            else if modBy 2 idx == 1 then
                Css.rgb 252 252 252

            else
                Css.rgb 255 255 255

        color =
            if isNowPlaying then
                Css.rgb 255 255 255

            else if isMissing then
                Color.toElmCssColor UI.Kit.colorKit.base04

            else
                Color.toElmCssColor UI.Kit.colors.text
    in
    [ Css.backgroundColor bgColor
    , Css.color color
    , Css.height (Css.px <| toFloat rowHeight)
    ]



-- COLUMNS


columnMinWidth =
    28


favouriteColumn : Bool -> Identifiers -> Html Msg
favouriteColumn favouritesOnly identifiers =
    brick
        [ css (favouriteColumnStyles favouritesOnly identifiers)
        , onClick (ToggleFavourite identifiers.indexInList)
        ]
        [ T.flex_shrink_0, T.pl3 ]
        [ if identifiers.isFavourite then
            text "t"

          else
            text "f"
        ]


favouriteColumnStyles : Bool -> Identifiers -> List Css.Style
favouriteColumnStyles favouritesOnly { isFavourite, isNowPlaying, isSelected } =
    let
        color =
            if isSelected then
                Color.toElmCssColor UI.Kit.colors.selectionAlt

            else if isNowPlaying && isFavourite then
                Css.rgb 255 255 255

            else if isNowPlaying then
                Css.rgba 255 255 255 0.4

            else if favouritesOnly || not isFavourite then
                Css.rgb 222 222 222

            else
                Color.toElmCssColor UI.Kit.colorKit.base08
    in
    [ Css.color color
    , Css.fontFamilies [ "or-favourites" ]
    , Css.minWidth (Css.px columnMinWidth)
    , Css.width (Css.pct 4.5)
    ]


playlistIndexColumn : Int -> Html msg
playlistIndexColumn indexInPlaylist =
    brick
        [ css (otherColumnStyles 4.5) ]
        [ T.pl2
        , T.pr2
        , C.pointer_events_none
        , T.truncate
        ]
        [ text (String.fromInt <| indexInPlaylist + 1) ]


otherColumn : Float -> Bool -> String -> Html msg
otherColumn width isLast text_ =
    brick
        [ css (otherColumnStyles width) ]
        [ T.pl2
        , C.pointer_events_none
        , T.truncate

        --
        , ifThenElse isLast T.pr3 T.pr2
        ]
        [ text text_ ]


otherColumnStyles : Float -> List Css.Style
otherColumnStyles columnWidth =
    [ Css.minWidth (Css.px columnMinWidth)
    , Css.width (Css.pct columnWidth)
    ]
